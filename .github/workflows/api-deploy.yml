# .github/workflows/api-deploy.yml
name: "API â€¢ CI + Deploy (Azure Container Apps)"

on:
  push:
    branches: [ main ]
    paths:
      - "backend/**"
      - "infrastructure/scripts/**"
      - ".github/workflows/**"
  pull_request:
    branches: [ main ]
    paths:
      - "backend/**"
      - ".github/workflows/**"
  workflow_dispatch: {}

# Default to least-privilege unless a job explicitly needs more
permissions:
  contents: read

# One run per branch; auto-cancel only for push/manual (not PRs)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name != 'pull_request' }}

env:
  # Azure resource names (adjust if these ever change)
  RG: rg-quizzical-shared
  APP: api-quizzical-dev
  ACR: acrquizzicaldev
  KV_NAME: quizzical-shared-kv
  PG_SERVER: pg-quizzical-dev
  DB_NAME: quiz
  APP_ENVIRONMENT: azure

jobs:
  # ======================
  # CI: Lint, Build & Test (non-blocking)
  # ======================
  build-and-test:
    name: "Build & Test"
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Let this job publish check runs for test results
    permissions:
      contents: read
      checks: write       # <-- required by publish-unit-test-result-action

    # Only affects `run:` steps (not `uses:`)
    defaults:
      run:
        working-directory: backend
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      # Install Poetry the supported way and create an in-project virtualenv
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      # Cache the in-project .venv based on the lockfile
      - name: Cache Poetry virtualenv
        id: poetry-cache
        uses: actions/cache@v4
        with:
          path: backend/.venv
          key: ${{ runner.os }}-py311-poetry-${{ hashFiles('backend/poetry.lock') }}

      - name: Install deps (Poetry)
        if: steps.poetry-cache.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      # Run Ruff via the official action; do not fail the job yet
      - name: Ruff (lint)
        uses: astral-sh/ruff-action@v3
        with:
          args: "check --config backend/pyproject.toml backend"
        continue-on-error: true  # allow failures during development
        env:
          RUFF_OUTPUT_FORMAT: github

      # Always create a junit XML, even if pytest crashes or tests fail
      - name: Pytest (always produce JUnit)
        run: |
          set -euo pipefail
          mkdir -p ../test-results
          # Try to run tests; never fail the step (we're publishing results either way)
          poetry run pytest \
            -q \
            --maxfail=1 \
            --disable-warnings \
            --junitxml=../test-results/pytest.junit.xml || true

          # If pytest didn't write the report (e.g., import error), create a minimal placeholder
          if [[ ! -s ../test-results/pytest.junit.xml ]]; then
            cat > ../test-results/pytest.junit.xml <<'XML'
            <?xml version="1.0" encoding="utf-8"?>
            <testsuite name="pytest" tests="0" failures="0" errors="1" skipped="0" time="0">
              <testcase classname="collection" name="startup">
                <error message="No tests collected or startup error">See job logs</error>
              </testcase>
            </testsuite>
            XML
          fi

      - name: Upload raw test results (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-junit
          path: test-results/pytest.junit.xml   # note: path is from repo root

      # Publish to Checks; runs even if pytest failed; needs checks: write
      - name: Publish Test Results
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: |
            test-results/**/*.xml
        # uncomment to avoid PR comments if you prefer only check runs:
        #   comment_mode: off

  # ======================
  # CD: Deploy (push to main or manual run only)
  # ======================
  deploy:
    name: "Deploy to Azure Container Apps"
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: build-and-test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    # Protect with an environment for approvals/secrets/audit
    environment:
      name: production

    # Least-privilege + OIDC for Azure
    permissions:
      id-token: write      # required by azure/login OIDC
      contents: read
      deployments: write   # record deployment & url if you choose

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure CLI extensions
        run: |
          set -euo pipefail
          az extension add --name containerapp --upgrade
          az extension add --name rdbms-connect --upgrade

      - name: Install jq for JSON parsing
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Ensure Postgres azure.extensions includes vector & uuid-ossp
        shell: bash
        run: |
          set -euo pipefail
          CUR="$(az postgres flexible-server parameter show \
            -g "$RG" -s "$PG_SERVER" -n azure.extensions --query value -o tsv || true)"

          add_if_missing() {
            local list="$1" item="$2"
            if [[ -z "$list" ]]; then echo "$item"; return; fi
            if echo "$list" | tr ',' '\n' | grep -qx "$item"; then
              echo "$list"
            else
              echo "${list},${item}"
            fi
          }

          NEW="$CUR"
          NEW="$(add_if_missing "$NEW" vector)"
          NEW="$(add_if_missing "$NEW" uuid-ossp)"

          if [[ "$NEW" != "$CUR" ]]; then
            echo "Updating azure.extensions to: $NEW"
            az postgres flexible-server parameter set \
              -g "$RG" -s "$PG_SERVER" -n azure.extensions -v "$NEW" 1>/dev/null
          else
            echo "Postgres azure.extensions already includes required entries."
          fi

      - name: Apply database schema (idempotent)
        env:
          PG_USER: ${{ secrets.PG_USER }}
          PG_PASS: ${{ secrets.PG_PASS }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Checking DB connectivity..."
          az postgres flexible-server execute \
            -n "$PG_SERVER" -u "$PG_USER" -p "$PG_PASS" -d "$DB_NAME" -q "SELECT 1;"

          echo "Applying schema via SQL file..."
          az postgres flexible-server execute \
            -n "$PG_SERVER" -u "$PG_USER" -p "$PG_PASS" -d "$DB_NAME" \
            --file-path backend/db/init/init.sql

      - name: Build & Deploy image to Container Apps
        uses: azure/container-apps-deploy-action@v2
        with:
          resourceGroup: ${{ env.RG }}
          containerAppName: ${{ env.APP }}
          acrName: ${{ env.ACR }}
          imageToBuild: ${{ env.ACR }}.azurecr.io/api-quizzical:${{ github.sha }}
          appSourcePath: ./backend
          dockerfilePath: Dockerfile
          targetPort: 8000
          ingress: external
          disableTelemetry: true

      - name: Bind secrets from Key Vault (authoritative)
        env:
          KV: ${{ env.KV_NAME }}
          APP_ENV: ${{ env.APP_ENVIRONMENT }}
          PROTECT_EXISTING: "1"
        run: |
          set -euo pipefail
          chmod +x infrastructure/scripts/bind-kv-dev.sh
          ./infrastructure/scripts/bind-kv-dev.sh

      - name: Sync non-secret env and bump revision
        env:
          APP_ENV: ${{ env.APP_ENVIRONMENT }}
          RESTART: "0"
        run: |
          set -euo pipefail
          chmod +x infrastructure/scripts/sync-nonsecret-env-dev.sh
          CONFIG_BUMP="$(date +%s)" ./infrastructure/scripts/sync-nonsecret-env-dev.sh azure

      - name: Resolve FQDN
        id: fqdn
        run: |
          set -euo pipefail
          FQDN="$(az containerapp show -g "$RG" -n "$APP" --query 'properties.configuration.ingress.fqdn' -o tsv)"
          echo "fqdn=${FQDN}" >> "$GITHUB_OUTPUT"
          echo "Public URL: https://${FQDN}"

      - name: Wait for readiness
        env:
          FQDN: ${{ steps.fqdn.outputs.fqdn }}
        run: |
          set -euo pipefail
          echo "Polling readiness at: https://${FQDN}/readiness"
          for i in {1..60}; do
            BODY="$(curl -sS --fail "https://${FQDN}/readiness" || true)"
            STATUS="$(echo "$BODY" | jq -r '.status // "none"')"
            REASON="$(echo "$BODY" | jq -r '.reason // "none"')"
            echo "Readiness poll ${i}/60: status=${STATUS} reason=${REASON}"
            if [[ "$STATUS" == "ready" ]]; then
              echo "Service is ready."
              exit 0
            fi
            sleep 5
          done
          echo "Timed out waiting for readiness. Last body:"
          echo "$BODY"
          exit 1

      - name: Output API docs URL
        if: always()
        env:
          FQDN: ${{ steps.fqdn.outputs.fqdn }}
        run: |
          echo "Docs: https://${FQDN}/docs"
