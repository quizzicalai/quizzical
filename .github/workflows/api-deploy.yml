# .github/workflows/api-deploy.yml
name: "API • CI + Deploy (Azure Container Apps)"

on:
  push:
    branches: [ main ]
    paths:
      - "backend/**"
      - "infrastructure/scripts/**"
      - ".github/workflows/**"
  pull_request:
    branches: [ main ]
    paths:
      - "backend/**"
      - ".github/workflows/**"
  workflow_dispatch: {}

# Default to least privilege at the workflow level; jobs elevate only if needed
permissions:
  contents: read

# One run per branch; cancel auto-reruns for push/manual (not PRs)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name != 'pull_request' }}

env:
  # Azure resource names (adjust if these change)
  RG: rg-quizzical-shared
  APP: api-quizzical-dev
  ACR: acrquizzicaldev
  KV_NAME: quizzical-shared-kv
  PG_SERVER: pg-quizzical-dev
  DB_NAME: quiz
  APP_ENVIRONMENT: azure

jobs:
  # ======================
  # CI: Lint (non-blocking)
  # ======================
  lint:
    name: "Ruff Lint (non-blocking)"
    runs-on: ubuntu-latest
    # Lint should *not* block deploy while you iterate
    continue-on-error: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Ruff (check)
        uses: astral-sh/ruff-action@v3
        with:
          # Use your repo config file; keep args explicit and stable
          args: "check --config backend/pyproject.toml backend"
        env:
          RUFF_OUTPUT_FORMAT: github  # proper annotations in Checks UI

  # ======================
  # CI: Tests (non-blocking)
  # ======================
  test:
    name: "Pytest (non-blocking)"
    runs-on: ubuntu-latest
    # Allow failures without blocking deploy
    continue-on-error: true

    # Allow the test publisher to create a Check Run
    permissions:
      contents: read
      checks: write

    defaults:
      run:
        shell: bash
        working-directory: backend

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Install Poetry (adds to PATH) and create an in-project venv
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      # Cache the in-project virtualenv; invalidate on lockfile change
      - name: Cache .venv
        id: poetry-cache
        uses: actions/cache@v4
        with:
          path: backend/.venv
          key: ${{ runner.os }}-py311-poetry-${{ hashFiles('backend/poetry.lock') }}

      - name: Install dependencies
        if: steps.poetry-cache.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Run Pytest (always write JUnit)
        run: |
          set -euo pipefail
          mkdir -p ../test-results
          # Don't fail the job even if collection/runtime errors occur
          poetry run pytest -q --maxfail=1 --disable-warnings \
            --junitxml=../test-results/pytest.junit.xml || true

          # Ensure a JUnit file exists even on catastrophic failure
          if [[ ! -s ../test-results/pytest.junit.xml ]]; then
            printf '%s\n' '<?xml version="1.0" encoding="utf-8"?>' \
              '<testsuite name="pytest" tests="0" failures="0" errors="1" skipped="0" time="0">' \
              '  <testcase classname="collection" name="startup">' \
              '    <error message="No tests collected or startup error">See job logs</error>' \
              '  </testcase>' \
              '</testsuite>' > ../test-results/pytest.junit.xml
          fi

      - name: Upload raw test results (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-junit
          path: test-results/pytest.junit.xml  # path is from repo root

      - name: Publish Test Results (Checks)
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: |
            test-results/**/*.xml

  # ======================
  # CD: Deploy (push to main / manual) — not blocked by CI
  # ======================
  deploy:
    name: "Deploy to Azure Container Apps"
    runs-on: ubuntu-latest
    timeout-minutes: 45

    # Do NOT add "needs:" — deploy remains independent of CI jobs above
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    # Attaching an environment sets OIDC subject to:
    #   repo:quizzicalai/quizzical:environment:production
    # Ensure your Entra federated credential matches that subject.
    environment:
      name: production

    # Least privilege for OIDC and deployment recording
    permissions:
      id-token: write
      contents: read
      deployments: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure CLI extensions
        run: |
          set -euo pipefail
          az extension add --name containerapp --upgrade
          az extension add --name rdbms-connect --upgrade

      - name: Install jq (JSON parsing)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Ensure Postgres azure.extensions includes vector & uuid-ossp
        shell: bash
        run: |
          set -euo pipefail
          CUR="$(az postgres flexible-server parameter show \
            -g "$RG" -s "$PG_SERVER" -n azure.extensions --query value -o tsv || true)"

          add_if_missing() {
            local list="$1" item="$2"
            if [[ -z "$list" ]]; then echo "$item"; return; fi
            if echo "$list" | tr ',' '\n' | grep -qx "$item"; then
              echo "$list"
            else
              echo "${list},${item}"
            fi
          }

          NEW="$CUR"
          NEW="$(add_if_missing "$NEW" vector)"
          NEW="$(add_if_missing "$NEW" uuid-ossp)"

          if [[ "$NEW" != "$CUR" ]]; then
            echo "Updating azure.extensions to: $NEW"
            az postgres flexible-server parameter set \
              -g "$RG" -s "$PG_SERVER" -n azure.extensions -v "$NEW" 1>/dev/null
          else
            echo "Postgres azure.extensions already includes required entries."
          fi

      - name: Apply database schema (idempotent)
        env:
          PG_USER: ${{ secrets.PG_USER }}
          PG_PASS: ${{ secrets.PG_PASS }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Checking DB connectivity..."
          az postgres flexible-server execute \
            -n "$PG_SERVER" -u "$PG_USER" -p "$PG_PASS" -d "$DB_NAME" -q "SELECT 1;"

          echo "Applying schema via SQL file..."
          az postgres flexible-server execute \
            -n "$PG_SERVER" -u "$PG_USER" -p "$PG_PASS" -d "$DB_NAME" \
            --file-path backend/db/init/init.sql

      - name: Build & Deploy image to Container Apps
        uses: azure/container-apps-deploy-action@v2
        with:
          resourceGroup: ${{ env.RG }}
          containerAppName: ${{ env.APP }}
          acrName: ${{ env.ACR }}
          imageToBuild: ${{ env.ACR }}.azurecr.io/api-quizzical:${{ github.sha }}
          appSourcePath: ./backend
          dockerfilePath: Dockerfile
          targetPort: 8000
          ingress: external

      - name: Bind secrets from Key Vault (authoritative)
        env:
          KV: ${{ env.KV_NAME }}
          APP_ENV: ${{ env.APP_ENVIRONMENT }}
          PROTECT_EXISTING: "1"
        run: |
          set -euo pipefail
          chmod +x infrastructure/scripts/bind-kv-dev.sh
          ./infrastructure/scripts/bind-kv-dev.sh

      - name: Sync non-secret env and bump revision
        env:
          APP_ENV: ${{ env.APP_ENVIRONMENT }}
          RESTART: "0"
        run: |
          set -euo pipefail
          chmod +x infrastructure/scripts/sync-nonsecret-env-dev.sh
          CONFIG_BUMP="$(date +%s)" ./infrastructure/scripts/sync-nonsecret-env-dev.sh azure

      - name: Resolve FQDN
        id: fqdn
        run: |
          set -euo pipefail
          FQDN="$(az containerapp show -g "$RG" -n "$APP" --query 'properties.configuration.ingress.fqdn' -o tsv)"
          echo "fqdn=${FQDN}" >> "$GITHUB_OUTPUT"
          echo "Public URL: https://${FQDN}"

      - name: Wait for readiness
        env:
          FQDN: ${{ steps.fqdn.outputs.fqdn }}
        run: |
          set -euo pipefail
          echo "Polling readiness at: https://${FQDN}/readiness"
          for i in {1..60}; do
            BODY="$(curl -sS --fail "https://${FQDN}/readiness" || true)"
            STATUS="$(echo "$BODY" | jq -r '.status // "none"')"
            REASON="$(echo "$BODY" | jq -r '.reason // "none"')"
            echo "Readiness poll ${i}/60: status=${STATUS} reason=${REASON}"
            if [[ "$STATUS" == "ready" ]]; then
              echo "Service is ready."
              exit 0
            fi
            sleep 5
          done
          echo "Timed out waiting for readiness. Last body:"
          echo "$BODY"
          exit 1

      - name: Output API docs URL
        if: always()
        env:
          FQDN: ${{ steps.fqdn.outputs.fqdn }}
        run: |
          echo "Docs: https://${FQDN}/docs"
